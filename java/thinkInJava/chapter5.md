# <center> 第 5 章 初始化与清理 </center>

> 在创建对象时，将位对象分配存储空间，并调用相应的构造器。确保你在使用的时候对象已经被恰当的初始化了。

- 构造器是一种特殊类型的方法，因为它没有返回值。与 `void` 返回值不同，构造器不会返回任何东西。

## 方法重载

> 让方法名相同而形参不同的方法存在，必须用到*方法重载*。

### 区分重载的方法

> 每一个重载的方法都必须有独一无二的参数列表( 方法名称和参数列表构成方法签名 )。

## `this` 关键字

> 有同一类型的两个对象 a 和 b，当着两个对象都调用 `peel()` 方法时，如何知道是被 a 还是 b 调用的，如下：

```java
    class Banana {
        void peel(int i){
            /**
            *
            */
        }
    }

    public class BananaPeel{
        public static void main (String [] args){
            Banana a = new Banana();
            Banana b = new Banana();
            a.peel(1);
            b.peel(2);
        }
    }

```

> 在这里，编译器在幕后把调用方法的对象的引用作为第一个参数传递给`peel()`， 如下:

```java
    Banana.peel(a, 1);
    Banana.peel(b, 2);
```

### 在构造器中调用构造器

- 构造器也是静态方法，即使没有 `static` 关键字。
- 基于方法的重载，可以为一个类编写多个构造器，并且可以在构造器中调用其他的构造器。
- 除了构造器之外，编译器禁止在其他任何方法中调用构造器。

## 清理：终结处理和垃圾回收

> Java 允许为对象定义`finalize()`方法：一旦垃圾回收器准备好是否对象占用的存储空间。 首先将调用`finalize()`方法，并且在下一次垃圾回收动作发生的时候才会真正回收内存；`C++`对象一定会被销毁，而 Java 对象并非总是被垃圾回收。

1. 对象可能不被垃圾回收。
2. 垃圾回收不等于“析构”。
3. 只要程序没有濒临存储空间用完的那一刻，对象占用的空间就总得不到释放。
4. Java 的对象存储与*堆*内存上，不能创建局部对象。
5. 绝对不能直接调用`finalize()`方法。

### 终结条件

> `System.gc()` 用于强制进行终结动作。

### 垃圾回收如何工作

> 垃圾回收器对于提高对象的创建速度有明显的效果。

- 垃圾回收器工作时，一面回收空间，一名使堆中的对象紧凑排列，这样“堆指针”就可以很容易移动到更靠近传送带的开始处。通过垃圾回收器对对象的重新排列，实现了一种高速的、有无限空间可供分配的堆模型。

### 非静态的实例初始化

> Java 中有被称为*实例初始化*的类似语法，用来初始化每一个对象的非静态变量。

```java
    public static Mugs{
        Mug mug1;
        Mug mug2;
        {  //实例初始化
            mug1 = new Mug();
            mug2 = new Mug();
        }
    }

```

- 实例初始化子句在构造器之前执行。

## 数组初始化

> 数组时相同类型的、用一个标识符名称封装到一起的一个对象序列或基本类型数据序列。

- 所有的数组都有一个固有成员`length`，通过它获知数组内包含了多少个元素。

```java
    int[] a1 = {1, 2, 3, 4, 5};
    int length = a1.length; //通过固有成员获取数组内的元素个数
```
